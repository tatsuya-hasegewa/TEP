#include "sys.h"
#include "serial.h"
#include "tep.h"
#include "ram4k.h"
#include "timer.h"

declare segment_reg {
  input     mode;
  input     page[3];
  input     PARin[12];
  output    PARout[12];
  func_in seg_read(mode,page);
  func_in writePAR(mode,page,PARin);
}

module sys {

 tep  	cpu;
 alt_ram4k	mainmem;
 serial_in  serrx;
 serial_out sertx;
 Mmu_add  mmu_adder;
 timer timer1;
 segment_reg   seg;

 reg run=0;
 reg ledout[8], anr[4], ssegr[8], seg0[8], seg1[8], seg2[8], seg3[8];
 reg intr_src[3] = 3'b111;
 reg intr_pc[16];
 reg    mmu_buf[16], PA[18];
 reg    ssr0_mode[2]=0, ssr0_page[3]=0, ssr0_sw=0, non_resident=0, readonly_error=0, length_error=0;
 reg   cmode=[2];

  wire       APF[3], BN[7], nBN[7], DIB[6], ACF[2], ED, AIB;
  wire       in_sel[16], out_sel[16], adr_sel[18];

 {

   if(~run & reset) {cpu.start(); run := 0b1; }//if(~run && reset) {cpu.start(); run := 1; }

   serrx.rxd = RXD;
   TXD = sertx.txd;

   VGA_R = 0b0;
   VGA_G = 0b0;
   VGA_B = 0b0;
   VGA_H = 0b1;
   VGA_V = 0b1;

   led = ledout;
   sseg = ~ssegr; an = ~anr;
   }

   {
    madr = mmu_buf;
    ssr0 = ssr0_sw;
    cmode = cmode;
   }

   {
    APF = cpu.adrs[15:13];
    BN  = cpu.adrs[12:06];
    nBN = ~cpu.adrs[12:06];
    DIB = cpu.adrs[05:00];
   }


  #define MAPPING   adr_sel[11:00]
  #define PAR_WRITE (out_sel[11:0])
  #define PAR_READ  ({0b0000,seg.PARout})

 func cpu.memory_write any {
	cpu.adrs < 0x8000 :{
		mainmem.memory_write(cpu.adrs,cpu.datao);
		if(cpu.ube) mainmem.ube();
		if(cpu.lbe) mainmem.lbe();
		if(mainmem.memory_ack) cpu.memory_ack();
		}
	cpu.adrs == 0xe000: /* display data */
	        {
		   sertx.port_write(cpu.datao[7:0]);
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe002: /* led data */
	        {
		   ledout := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe008: /* led data */
	        {
		   seg0 := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe009: /* led data */
	        {
		   seg1 := cpu.datao[15:8];
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe00a: /* led data */
	        {
		   seg2 := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe00b: /* led data */
	        {
		   seg3 := cpu.datao[15:8];
		   cpu.memory_ack();
		}
	0xf000 <= cpu.adrs && cpu.adrs <= 0xf007: /*F000 ~ F007 int timer1*/
			{
			timer1.write(cpu.adrs[2:1], cpu.datao);
		   	cpu.memory_ack();
		}
	cpu.adrs == 0xfe02: /* intrrupted pc */
	    {
			intr_pc := cpu.datao;
		   	cpu.memory_ack();
		}
  	0xd000 <= cpu.adrs && cpu.adrs <= 0xd017:/* D000 ~ D017 segmentreg */
        {
      adr_sel :=cpu.datao;
      cpu.memory_ack();
    }
	cpu.adrs == 0xd018: /* SSR0 */
	    {
			out_sel := cpu.datao;
		   	cpu.memory_ack();
    }

	cpu.adrs == 0xde00: /* mode */
	    {
			cmode := cpu.datao[1:0];
		   	cpu.memory_ack();
		}
	}

 func cpu.memory_read any {
	cpu.adrs == 0xe000: /* keyboard data */
	        {
		   cpu.datai = {0x00, serrx.data};
		   cpu.memory_ack();
		}
	cpu.adrs == 0xe001: {/* keyboard, display status */
		   cpu.datai = {serrx.rxready, sertx.txbusy,
		               0b000000, 0x00};
		   cpu.memory_ack();
		   }
	cpu.adrs == 0xe002: /* sw data */
	        {
		   cpu.datai = {0x00, sw};
		   cpu.memory_ack();
		}
	0xf000 <= cpu.adrs && cpu.adrs <= 0xf007: /*F000 ~ F007 int timer1*/
			{
			cpu.datai = timer1.read(cpu.adrs[2:1]);
		   	cpu.memory_ack();
		}
	cpu.adrs == 0xfe00: /* intr source */
	    {
			cpu.datai = 16'(intr_src);
		   	cpu.memory_ack();
		}
	cpu.adrs == 0xfe02: /* intrrupted pc */
	    {
			cpu.datai = intr_pc;
		   	cpu.memory_ack();
		}
	cpu.adrs < 0x8000: {
		ledout := cpu.adrs[7:0];
		cpu.datai = mainmem.memory_read(cpu.adrs).datao;
		if(cpu.ube) mainmem.ube();
		if(cpu.lbe) mainmem.lbe();
		if(mainmem.memory_ack) cpu.memory_ack();
		}

  0xd000 <= cpu.adrs && cpu.adrs <= 0xd017:/* D000 ~ D017 segmentreg */
      {
    cpu.datai = seg.seg_read(CPU_MODE, APF)
    cpu.memory_ack();
     }
	cpu.adrs == 0xd018: /* SSR0 */
	    {
			cpu.datai = {non_resident,length_error,readonly_error,(0b000000),ssr0_mode,0b0,ssr0_page,ssr0_sw};
		   	cpu.memory_ack();
		}
	cpu.adrs == 0xde00: /* mode */
	    {
			cpu.datai = cmode;
		   	cpu.memory_ack();
		}
	}

#define TIMER 3'b000

	func timer1.intr{
		intr_src := TIMER;
		cpu.int_signal();
	}

/*
 * Memory Management Unit
 */

 #define CPU_MODE (&cmode)

 {
  {
    state_name s0,s1,s2;
    first_state s0;
    state s0 {
      /* Virtual Address 160000 to 177777 is mapped from 760000 to 777777 */
      if(~ssr0_sw) {
       if(cpu.rd) mmu_buf := mrd( {(&APF),(&APF),cpu.adrs} ).in_sel;
       if(cpu.wt) mwt( {(&APF),(&APF),cpu.adrs}, cpu.dato );
        goto s2;
      }
      /* Compute Physical Address */
      if(ssr0_sw ) {
        seg.seg_read(CPU_MODE, APF);
        PA := {mmu_adder.do({0b00000,BN}, seg.PARout, 0b0).out,DIB};
        goto s1;
      }
    }
    state s1 {
      if(cpu.rd) mmu_buf := mrd(PA).in_sel;
      if(cpu.wt) mwt(PA, cpu.dato);
      goto s2;
    }
    state s2 {
//      cpu.rdy();
      if(cpu.rd) cpu.dati = mmu_buf;
      goto s0;
    }
  } /* end of mmu */
 }
}

module segment_reg {
  /* Kernel Mode Page Address Reg and Page Discription Reg */
  reg  k_par0[12]=0;
  reg  k_par1[12]=0;
  reg  k_par2[12]=0;
  reg  k_par3[12]=0;
  reg  k_par4[12]=0;
  reg  k_par5[12]=0;
  reg  k_par6[12]=0;
  reg  k_par7[12]=0;

    /* User Mode Page Address Reg and Page Discription Reg */
  reg  u_par0[12]=0;
  reg  u_par1[12]=0;
  reg  u_par2[12]=0;
  reg  u_par3[12]=0;
  reg  u_par4[12]=0;
  reg  u_par5[12]=0;
  reg  u_par6[12]=0;
  reg  u_par7[12]=0;

  func seg_read any {
    (~mode)&(page == 0o0): { PARout = k_par0; }
    (~mode)&(page == 0o1): { PARout = k_par1; }
    (~mode)&(page == 0o2): { PARout = k_par2; }
    (~mode)&(page == 0o3): { PARout = k_par3; }
    (~mode)&(page == 0o4): { PARout = k_par4; }
    (~mode)&(page == 0o5): { PARout = k_par5; }
    (~mode)&(page == 0o6): { PARout = k_par6; }
    (~mode)&(page == 0o7): { PARout = k_par7; }
    ( mode)&(page == 0o0): { PARout = u_par0; }
    ( mode)&(page == 0o1): { PARout = u_par1; }
    ( mode)&(page == 0o2): { PARout = u_par2; }
    ( mode)&(page == 0o3): { PARout = u_par3; }
    ( mode)&(page == 0o4): { PARout = u_par4; }
    ( mode)&(page == 0o5): { PARout = u_par5; }
    ( mode)&(page == 0o6): { PARout = u_par6; }
    ( mode)&(page == 0o7): { PARout = u_par7; }
  }
  func writePAR any {
    (~mode)&(page == 0o0): k_par0 := PARin;
    (~mode)&(page == 0o1): k_par1 := PARin;
    (~mode)&(page == 0o2): k_par2 := PARin;
    (~mode)&(page == 0o3): k_par3 := PARin;
    (~mode)&(page == 0o4): k_par4 := PARin;
    (~mode)&(page == 0o5): k_par5 := PARin;
    (~mode)&(page == 0o6): k_par6 := PARin;
    (~mode)&(page == 0o7): k_par7 := PARin;
    ( mode)&(page == 0o0): u_par0 := PARin;
    ( mode)&(page == 0o1): u_par1 := PARin;
    ( mode)&(page == 0o2): u_par2 := PARin;
    ( mode)&(page == 0o3): u_par3 := PARin;
    ( mode)&(page == 0o4): u_par4 := PARin;
    ( mode)&(page == 0o5): u_par5 := PARin;
    ( mode)&(page == 0o6): u_par6 := PARin;
    ( mode)&(page == 0o7): u_par7 := PARin;
  }
}/* end of segment */
