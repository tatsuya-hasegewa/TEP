#include "sys.h"
#include "serial.h"
#include "tep.h"
#include "ram4k.h"
#include "timer.h"
//#include "Mmu_add.h"

/*declare mmu_adder{
	output    mmuadrs;
}*/
declare segment_reg {
  input     mode;
  input     page[3];
  input     PARin[8];
  output    PARout[8];
  func_in seg_read(mode,page);
  func_in writePAR(mode,page,PARin);
}

module sys {

 tep  	cpu;
 alt_ram4k	mainmem;
 serial_in  serrx;
 serial_out sertx;
 //Mmu_add  mmu_adder;
 timer timer1;
 segment_reg   seg;

 reg run=0;
 reg ledout[8], anr[4], ssegr[8], seg0[8], seg1[8], seg2[8], seg3[8];
 reg intr_src[3] = 3'b111;
 reg intr_pc[16];
 reg    mmu_adrs[16];
 reg    ssr0_mode[2]=0, ssr0_page[3]=0, ssr0_sw=0;
 reg   cmode[2]=0;

  wire       APF[3], BN[5], nBN[5], DIB[8], ED;
  wire       in_sel[16], out_sel[16];

 {

   if(~run & reset) {cpu.start(); run := 0b1; }//if(~run && reset) {cpu.start(); run := 1; }

   serrx.rxd = RXD;
   TXD = sertx.txd;

   VGA_R = 0b0;
   VGA_G = 0b0;
   VGA_B = 0b0;
   VGA_H = 0b1;
   VGA_V = 0b1;

   led = ledout;
   sseg = ~ssegr; an = ~anr;
	 //out_sel := {(0b000000000),ssr0_mode,0b0,ssr0_page,ssr0_sw};
   }

   {
    APF = cpu.adrs[15:13];
    BN  = cpu.adrs[12:08];
    nBN = ~cpu.adrs[12:08];
    DIB = cpu.adrs[07:00];
   }



 func cpu.memory_write any {
	mmu_adrs < 0x8000 :{
		mainmem.memory_write(mmu_adrs,cpu.datao);
		if(cpu.ube) mainmem.ube();
		if(cpu.lbe) mainmem.lbe();
		if(mainmem.memory_ack) cpu.memory_ack();
		}
	mmu_adrs == 0xe000: /* display data */
	        {
		   sertx.port_write(cpu.datao[7:0]);
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe002: /* led data */
	        {
		   ledout := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe008: /* led data */
	        {
		   seg0 := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe009: /* led data */
	        {
		   seg1 := cpu.datao[15:8];
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe00a: /* led data */
	        {
		   seg2 := cpu.datao[7:0];
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe00b: /* led data */
	        {
		   seg3 := cpu.datao[15:8];
		   cpu.memory_ack();
		}
	0xf000 <= mmu_adrs && mmu_adrs <= 0xf007: /*F000 ~ F007 int timer1*/
			{
			timer1.write(mmu_adrs[2:1], cpu.datao);
		   	cpu.memory_ack();
		}
	mmu_adrs == 0xfe02: /* intrrupted pc */
	    {
			intr_pc := cpu.datao;
		   	cpu.memory_ack();
		}
  	0xd000 <= mmu_adrs && mmu_adrs <= 0xd017:/* D000 ~ D017 segmentreg */
        {
      seg.writePAR(cmode,mmu_adrs[15:13],cpu.datao);
      cpu.memory_ack();
    }
	mmu_adrs == 0xd018: /* SSR0 */
	    {
			out_sel = cpu.datao;
		   	cpu.memory_ack();
    }

	mmu_adrs == 0xde00: /* mode */
	    {
			cmode := cpu.datao[1:0];
		   	cpu.memory_ack();
		}
	}

 func cpu.memory_read any {
	mmu_adrs == 0xe000: /* keyboard data */
	        {
		   cpu.datai = {0x00, serrx.data};
		   cpu.memory_ack();
		}
	mmu_adrs == 0xe001: {/* keyboard, display status */
		   cpu.datai = {serrx.rxready, sertx.txbusy,
		               0b000000, 0x00};
		   cpu.memory_ack();
		   }
	mmu_adrs == 0xe002: /* sw data */
	        {
		   cpu.datai = {0x00, sw};
		   cpu.memory_ack();
		}
	0xf000 <= mmu_adrs && mmu_adrs <= 0xf007: /*F000 ~ F007 int timer1*/
			{
			cpu.datai = timer1.read(cpu.adrs[2:1]);
		   	cpu.memory_ack();
		}
	mmu_adrs == 0xfe00: /* intr source */
	    {
			cpu.datai = 16'(intr_src);
		   	cpu.memory_ack();
		}
	mmu_adrs == 0xfe02: /* intrrupted pc */
	    {
			cpu.datai = intr_pc;
		   	cpu.memory_ack();
		}
	mmu_adrs < 0x8000: {
		ledout := mmu_adrs[7:0];
		cpu.datai = mainmem.memory_read(mmu_adrs).datao;
		if(cpu.ube) mainmem.ube();
		if(cpu.lbe) mainmem.lbe();
		if(mainmem.memory_ack) cpu.memory_ack();
		}

  0xd000 <= mmu_adrs && mmu_adrs <= 0xd017:/* D000 ~ D017 segmentreg */
      {
    cpu.datai = seg.PARout;
    cpu.memory_ack();
     }
	mmu_adrs == 0xd018: /* SSR0 */
	    {
			cpu.datai = {(0b000000000),ssr0_mode,0b0,ssr0_page,ssr0_sw};
		   	cpu.memory_ack();
		}
	mmu_adrs == 0xde00: /* mode */
	    {
			cpu.datai = cmode;
		   	cpu.memory_ack();
		}
	}

#define TIMER 3'b000

	func timer1.intr{
		intr_src := TIMER;
		cpu.int_signal();
	}

/*
 * Memory Management Unit
 */

 {
  if(ssr0_sw ){
    seg.seg_read(cmode, APF);
    mmu_adrs := {seg.PARout,DIB};
  }
  else{
    mmu_adrs := cpu.adrs;
  }
 }
}

/*module mmu_adder {
	APF = cpu.adrs[15:13]
	DIB = cpu.adrs[07:00]
	mmu = {seg.seg_read(cmode, APF), DIB};
}*/

module segment_reg {
  /* Kernel Mode Page Address Reg and Page Discription Reg */
  reg  k_par0[8]=0;
  reg  k_par1[8]=0;
  reg  k_par2[8]=0;
  reg  k_par3[8]=0;
  reg  k_par4[8]=0;
  reg  k_par5[8]=0;
  reg  k_par6[8]=0;
  reg  k_par7[8]=0;

    /* User Mode Page Address Reg and Page Discription Reg */
  reg  u_par0[8]=0;
  reg  u_par1[8]=0;
  reg  u_par2[8]=0;
  reg  u_par3[8]=0;
  reg  u_par4[8]=0;
  reg  u_par5[8]=0;
  reg  u_par6[8]=0;
  reg  u_par7[8]=0;

  func seg_read any {
    (~mode)&(page == 0o0): { PARout = k_par0; }
    (~mode)&(page == 0o1): { PARout = k_par1; }
    (~mode)&(page == 0o2): { PARout = k_par2; }
    (~mode)&(page == 0o3): { PARout = k_par3; }
    (~mode)&(page == 0o4): { PARout = k_par4; }
    (~mode)&(page == 0o5): { PARout = k_par5; }
    (~mode)&(page == 0o6): { PARout = k_par6; }
    (~mode)&(page == 0o7): { PARout = k_par7; }
    ( mode)&(page == 0o0): { PARout = u_par0; }
    ( mode)&(page == 0o1): { PARout = u_par1; }
    ( mode)&(page == 0o2): { PARout = u_par2; }
    ( mode)&(page == 0o3): { PARout = u_par3; }
    ( mode)&(page == 0o4): { PARout = u_par4; }
    ( mode)&(page == 0o5): { PARout = u_par5; }
    ( mode)&(page == 0o6): { PARout = u_par6; }
    ( mode)&(page == 0o7): { PARout = u_par7; }
  }
  func writePAR any {
    (~mode)&(page == 0o0): k_par0 := PARin;
    (~mode)&(page == 0o1): k_par1 := PARin;
    (~mode)&(page == 0o2): k_par2 := PARin;
    (~mode)&(page == 0o3): k_par3 := PARin;
    (~mode)&(page == 0o4): k_par4 := PARin;
    (~mode)&(page == 0o5): k_par5 := PARin;
    (~mode)&(page == 0o6): k_par6 := PARin;
    (~mode)&(page == 0o7): k_par7 := PARin;
    ( mode)&(page == 0o0): u_par0 := PARin;
    ( mode)&(page == 0o1): u_par1 := PARin;
    ( mode)&(page == 0o2): u_par2 := PARin;
    ( mode)&(page == 0o3): u_par3 := PARin;
    ( mode)&(page == 0o4): u_par4 := PARin;
    ( mode)&(page == 0o5): u_par5 := PARin;
    ( mode)&(page == 0o6): u_par6 := PARin;
    ( mode)&(page == 0o7): u_par7 := PARin;
  }
}/* end of segment */
